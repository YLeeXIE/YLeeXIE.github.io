<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>代码猿</title>
<meta name="description" content="一入编程深似海
从此妹子是路人" />
<link rel="shortcut icon" href="https://yleexie.github.io/favicon.ico?v=1570726535154">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://yleexie.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="代码猿 - Atom Feed" href="https://yleexie.github.io/atom.xml">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://yleexie.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://yleexie.github.io/images/avatar.png?v=1570726535154" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">代码猿</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            
          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"><img src="https://cdn.img.wenhairu.com/images/2019/10/10/8hMaB.png" alt="8hMaB.png" border="0">&nbsp;&nbsp;代码猿</div>
    <!-- <a class="rss" href="https://yleexie.github.io/atom.xml" target="_blank">RSS</a> -->
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">8个实用Python的脚本，收藏备用</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2019-10-10 / 13 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2205610465,2865676578&amp;fm=26&amp;gp=0.jpg" alt="">
        
        <div class="post-content yue">
          <p>脚本写的好，下班下得早!程序员的日常工作除了编写程序代码，还不可避免地需要处理相关的测试和验证工作。</p>
<p>例如，访问某个网站一直不通，需要确定此地址是否可访问，服务器返回什么，进而确定问题在于什么。完成这个任务，如果一味希望采用编译型语言来编写这样的代码，实践中的时间和精力是不够的，这个时候就需要发挥脚本的神奇作用!</p>
<p>好不夸张的说，能否写出高效实用的脚本代码，直接影响着一个程序员的幸福生活[下班时间]。下面整理 8 个实用的 Python 脚本，需要的时候改改直接用，建议收藏!</p>
<ol>
<li>解决 linux 下 unzip 乱码的</li>
</ol>
<pre><code>import os 
import sys 
import zipfile 
import argparse 
s = '\\x1b[%d;%dm%s\\x1b[0m'  
def unzip(path): 
 file = zipfile.ZipFile(path,&quot;r&quot;) 
 if args.secret: 
 file.setpassword(args.secret) 
 for name in file.namelist(): 
 try: 
 utf8name=name.decode('gbk') 
 pathname = os.path.dirname(utf8name) 
 except: 
 utf8name=name 
 pathname = os.path.dirname(utf8name) 
 #print s % (1, 92, ' &gt;&gt; extracting:'), utf8name 
 #pathname = os.path.dirname(utf8name) 
 if not os.path.exists(pathname) and pathname != &quot;&quot;: 
 os.makedirs(pathname) 
 data = file.read(name) 
 if not os.path.exists(utf8name): 
 try: 
 fo = open(utf8name, &quot;w&quot;) 
 fo.write(data) 
 fo.close 
 except: 
 pass 
 file.close() 
def main(argv): 
 ###################################################### 
 # for argparse 
 p = argparse.ArgumentParser(description='解决unzip乱码') 
 p.add_argument('xxx', type=str, nargs='*', \ 
 help='命令对象.') 
 p.add_argument('-s', '--secret', action='store', \ 
 default=None, help='密码') 
 global args 
 args = p.parse_args(argv[1:]) 
 xxx = args.xxx 
 for path in xxx: 
 if path.endswith('.zip'): 
 if os.path.exists(path): 
 print s % (1, 97, ' ++ unzip:'), path 
 unzip(path) 
 else: 
 print s % (1, 91, ' !! file doesn\'t exist.'), path 
 else: 
 print s % (1, 91, ' !! file isn\'t a zip file.'), path 
if __name__ == '__main__': 
 argv = sys.argv 
 main(argv) 
</code></pre>
<ol start="2">
<li>统计当前根目录代码行数。</li>
</ol>
<pre><code># coding=utf-8 
import os 
import time 
# 设定根目录 
basedir = './' 
filelists = [] 
# 指定想要统计的文件类型 
whitelist = ['cpp', 'h'] 
#遍历文件, 递归遍历文件夹中的所有 
def getFile(basedir): 
 global filelists 
 for parent,dirnames,filenames in os.walk(basedir): 
 for filename in filenames: 
 ext = filename.split('.')[-1] 
 #只统计指定的文件类型，略过一些log和cache文件 
 if ext in whitelist: 
 filelists.append(os.path.join(parent,filename)) 
#统计一个的行数 
def countLine(fname): 
 count = 0 
 # 把文件做二进制看待,read. 
 for file_line in open(fname, 'rb').readlines(): 
 if file_line != '' and file_line != '\n': #过滤掉空行 
 count += 1 
 print (fname + '----' , count) 
 return count 
if __name__ == '__main__' : 
 startTime = time.clock() 
 getFile(basedir) 
 totalline = 0 
 for filelist in filelists: 
 totalline = totalline + countLine(filelist) 
 print ('total lines:',totalline) 
 print ('Done! Cost Time: %0.2f second' % (time.clock() - startTime)) 
</code></pre>
<ol start="3">
<li>扫描当前目录和所有子目录并显示大小。</li>
</ol>
<pre><code>import os 
import sys  
try: 
 directory = sys.argv[1]  
except IndexError: 
 sys.exit(&quot;Must provide an argument.&quot;) 
dir_size = 0  
fsizedicr = {'Bytes': 1, 
 'Kilobytes': float(1) / 1024, 
 'Megabytes': float(1) / (1024 * 1024), 
 'Gigabytes': float(1) / (1024 * 1024 * 1024)} 
for (path, dirs, files) in os.walk(directory):  
 for file in files:  
 filename = os.path.join(path, file) 
 dir_size += os.path.getsize(filename)  
fsizeList = [str(round(fsizedicr[key] * dir_size, 2)) + &quot; &quot; + key for key in fsizedicr]  
if dir_size == 0: print (&quot;File Empty&quot;)  
else: 
 for units in sorted(fsizeList)[::-1]:  
 print (&quot;Folder Size: &quot; + units) 
</code></pre>
<ol start="4">
<li>将源目录240天以上的所有文件移动到目标目录。</li>
</ol>
<pre><code>import shutil 
import sys 
import time 
import os 
import argparse 
usage = 'python move_files_over_x_days.py -src [SRC] -dst [DST] -days [DAYS]' 
description = 'Move files from src to dst if they are older than a certain number of days. Default is 240 days' 
args_parser = argparse.ArgumentParser(usage=usage, description=description) 
args_parser.add_argument('-src', '--src', type=str, nargs='?', default='.', help='(OPTIONAL) Directory where files will be moved from. Defaults to current directory') 
args_parser.add_argument('-dst', '--dst', type=str, nargs='?', required=True, help='(REQUIRED) Directory where files will be moved to.') 
args_parser.add_argument('-days', '--days', type=int, nargs='?', default=240, help='(OPTIONAL) Days value specifies the minimum age of files to be moved. Default is 240.') 
args = args_parser.parse_args() 
if args.days &lt; 0: 
    args.days = 0 
src = args.src # 设置源目录 
dst = args.dst # 设置目标目录 
days = args.days # 设置天数 
now = time.time() # 获得当前时间 
if not os.path.exists(dst): 
    os.mkdir(dst) 
for f in os.listdir(src): # 遍历源目录所有文件 
 if os.stat(f).st_mtime &lt; now - days * 86400: # 判断是否超过240天 
 if os.path.isfile(f): # 检查是否是文件 
 shutil.move(f, dst) # 移动文件 
</code></pre>
<ol start="5">
<li>扫描脚本目录，并给出不同类型脚本的计数。</li>
</ol>
<pre><code>import os     
import shutil             
from time import strftime                                                
logsdir=&quot;c:\logs\puttylogs&quot;    
zipdir=&quot;c:\logs\puttylogs\zipped_logs&quot;                           
zip_program=&quot;zip.exe&quot;                                                
for files in os.listdir(logsdir):           
    if files.endswith(&quot;.log&quot;):                                       
        files1=files+&quot;.&quot;+strftime(&quot;%Y-%m-%d&quot;)+&quot;.zip&quot;         
        os.chdir(logsdir)                                                
        os.system(zip_program + &quot; &quot; + files1 +&quot; &quot;+ files)    
        shutil.move(files1, zipdir)   
        os.remove(files)
</code></pre>
<ol start="6">
<li>下载Leetcode的算法题。</li>
</ol>
<pre><code>import sys 
import re 
import os 
import argparse 
import requests 
from lxml import html as lxml_html 
try: 
 import html 
except ImportError: 
 import HTMLParser 
 html = HTMLParser.HTMLParser() 
try: 
 import cPickle as pk 
except ImportError: 
 import pickle as pk 
class LeetcodeProblems(object): 
 def get_problems_info(self): 
 leetcode_url = 'https://leetcode.com/problemset/algorithms' 
 res = requests.get(leetcode_url) 
 if not res.ok: 
 print('request error') 
 sys.exit() 
 cm = res.text 
 cmt = cm.split('tbody&gt;')[-2] 
 indexs = re.findall(r'&lt;td&gt;(\d+)&lt;/td&gt;', cmt) 
 problem_urls = ['https://leetcode.com' + url \ 
 for url in re.findall( 
 r'&lt;a href=&quot;(/problems/.+?)&quot;', cmt)] 
 levels = re.findall(r&quot;&lt;td value='\d*'&gt;(.+?)&lt;/td&gt;&quot;, cmt) 
 tinfos = zip(indexs, levels, problem_urls) 
 assert (len(indexs) == len(problem_urls) == len(levels)) 
 infos = [] 
 for info in tinfos: 
 res = requests.get(info[-1]) 
 if not res.ok: 
 print('request error') 
 sys.exit() 
 tree = lxml_html.fromstring(res.text) 
 title = tree.xpath('//meta[@property=&quot;og:title&quot;]/@content')[0] 
 description = tree.xpath('//meta[@property=&quot;description&quot;]/@content') 
 if not description: 
 description = tree.xpath('//meta[@property=&quot;og:description&quot;]/@content')[0] 
 else: 
 description = description[0] 
 description = html.unescape(description.strip()) 
 tags = tree.xpath('//div[@id=&quot;tags&quot;]/following::a[@]/text()') 
 infos.append( 
 { 
 'title': title, 
 'level': info[1], 
 'index': int(info[0]), 
 'description': description, 
 'tags': tags 
 } 
 ) 
 with open('leecode_problems.pk', 'wb') as g: 
 pk.dump(infos, g) 
 return infos 
 def to_text(self, pm_infos): 
 if self.args.index: 
 key = 'index' 
 elif self.args.title: 
 key = 'title' 
 elif self.args.tag: 
 key = 'tags' 
 elif self.args.level: 
 key = 'level' 
 else: 
 key = 'index' 
 infos = sorted(pm_infos, key=lambda i: i[key]) 
 text_template = '## {index} - {title}\n' \ 
 '~{level}~ {tags}\n' \ 
 '{description}\n' + '\n' * self.args.line 
 text = '' 
 for info in infos: 
 if self.args.rm_blank: 
 info['description'] = re.sub(r'[\n\r]+', r'\n', info['description']) 
 text += text_template.format(**info) 
 with open('leecode problems.txt', 'w') as g: 
 g.write(text) 
 def run(self): 
 if os.path.exists('leecode_problems.pk') and not self.args.redownload: 
 with open('leecode_problems.pk', 'rb') as f: 
 pm_infos = pk.load(f) 
 else: 
 pm_infos = self.get_problems_info() 
 print('find %s problems.' % len(pm_infos)) 
 self.to_text(pm_infos) 
def handle_args(argv): 
 p = argparse.ArgumentParser(description='extract all leecode problems to location') 
 p.add_argument('--index', action='store_true', help='sort by index') 
 p.add_argument('--level', action='store_true', help='sort by level') 
 p.add_argument('--tag', action='store_true', help='sort by tag') 
 p.add_argument('--title', action='store_true', help='sort by title') 
 p.add_argument('--rm_blank', action='store_true', help='remove blank') 
 p.add_argument('--line', action='store', type=int, default=10, help='blank of two problems') 
 p.add_argument('-r', '--redownload', action='store_true', help='redownload data') 
 args = p.parse_args(argv[1:]) 
 return args 
def main(argv): 
 args = handle_args(argv) 
 x = LeetcodeProblems() 
 x.args = args 
 x.run() 
if __name__ == '__main__': 
 argv = sys.argv 
 main(argv) 
</code></pre>
<ol start="7">
<li>将 Markdown 转换为 HTML。</li>
</ol>
<pre><code>import sys 
import os 
from bs4 import BeautifulSoup 
import markdown 
class MarkdownToHtml: 
 headTag = '&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;' 
 def __init__(self,cssFilePath = None): 
 if cssFilePath != None: 
 self.genStyle(cssFilePath) 
 def genStyle(self,cssFilePath): 
 with open(cssFilePath,'r') as f: 
 cssString = f.read() 
 self.headTag = self.headTag[:-7] + '&lt;style type=&quot;text/css&quot;&gt;{}&lt;/style&gt;'.format(cssString) + self.headTag[-7:] 
 def markdownToHtml(self, sourceFilePath, destinationDirectory = None, outputFileName = None): 
 if not destinationDirectory: 
 # 未定义输出目录则将源文件目录(注意要转换为绝对路径)作为输出目录 
 destinationDirectory = os.path.dirname(os.path.abspath(sourceFilePath)) 
 if not outputFileName: 
 # 未定义输出文件名则沿用输入文件名 
 outputFileName = os.path.splitext(os.path.basename(sourceFilePath))[0] + '.html' 
 if destinationDirectory[-1] != '/': 
 destinationDirectory += '/' 
 with open(sourceFilePath,'r', encoding='utf8') as f: 
 markdownText = f.read() 
 # 编译出原始 HTML 文本 
 rawHtml = self.headTag + markdown.markdown(markdownText,output_format='html5') 
 # 格式化 HTML 文本为可读性更强的格式 
 beautifyHtml = BeautifulSoup(rawHtml,'html5lib').prettify() 
 with open(destinationDirectory + outputFileName, 'w', encoding='utf8') as f: 
 f.write(beautifyHtml) 
if __name__ == &quot;__main__&quot;: 
 mth = MarkdownToHtml() 
 # 做一个命令行参数列表的浅拷贝，不包含脚本文件名 
 argv = sys.argv[1:] 
 # 目前列表 argv 可能包含源文件路径之外的元素（即选项信息） 
 # 程序最后遍历列表 argv 进行编译 markdown 时，列表中的元素必须全部是源文件路径 
 outputDirectory = None 
 if '-s' in argv: 
 cssArgIndex = argv.index('-s') +1 
 cssFilePath = argv[cssArgIndex] 
 # 检测样式表文件路径是否有效 
 if not os.path.isfile(cssFilePath): 
 print('Invalid Path: '+cssFilePath) 
 sys.exit() 
 mth.genStyle(cssFilePath) 
 # pop 顺序不能随意变化 
 argv.pop(cssArgIndex) 
 argv.pop(cssArgIndex-1) 
 if '-o' in argv: 
 dirArgIndex = argv.index('-o') +1 
 outputDirectory = argv[dirArgIndex] 
 # 检测输出目录是否有效 
 if not os.path.isdir(outputDirectory): 
 print('Invalid Directory: ' + outputDirectory) 
 sys.exit() 
 # pop 顺序不能随意变化 
 argv.pop(dirArgIndex) 
 argv.pop(dirArgIndex-1) 
 # 至此，列表 argv 中的元素均是源文件路径 
 # 遍历所有源文件路径 
 for filePath in argv: 
 # 判断文件路径是否有效 
 if os.path.isfile(filePath): 
 mth.markdownToHtml(filePath, outputDirectory) 
 else: 
 print('Invalid Path: ' + filePath) 
</code></pre>
<ol start="8">
<li>文本文件编码检测与转换。</li>
</ol>
<pre><code>import sys 
import os 
import argparse 
from chardet.universaldetector import UniversalDetector 
parser = argparse.ArgumentParser(description = '文本文件编码检测与转换') 
parser.add_argument('filePaths', nargs = '+', 
 help = '检测或转换的文件路径') 
parser.add_argument('-e', '--encoding', nargs = '?', const = 'UTF-8', 
 help = ''' 
目标编码。支持的编码有： 
ASCII, (Default) UTF-8 (with or without a BOM), UTF-16 (with a BOM), 
UTF-32 (with a BOM), Big5, GB2312/GB18030, EUC-TW, HZ-GB-2312, ISO-2022-CN, EUC-JP, SHIFT_JIS, ISO-2022-JP, 
ISO-2022-KR, KOI8-R, MacCyrillic, IBM855, IBM866, ISO-8859-5, windows-1251, ISO-8859-2, windows-1250, EUC-KR, 
ISO-8859-5, windows-1251, ISO-8859-1, windows-1252, ISO-8859-7, windows-1253, ISO-8859-8, windows-1255, TIS-620 
''') 
parser.add_argument('-o', '--output', 
 help = '输出目录') 
# 解析参数，得到一个 Namespace 对象 
args = parser.parse_args() 
# 输出目录不为空即视为开启转换, 若未指定转换编码，则默认为 UTF-8 
if args.output != None: 
 if not args.encoding: 
 # 默认使用编码 UTF-8 
 args.encoding = 'UTF-8' 
 # 检测用户提供的输出目录是否有效 
 if not os.path.isdir(args.output): 
 print('Invalid Directory: ' + args.output) 
 sys.exit() 
 else: 
 if args.output[-1] != '/': 
 args.output += '/' 
# 实例化一个通用检测器 
detector = UniversalDetector() 
print() 
print('Encoding (Confidence)',':','File path') 
for filePath in args.filePaths: 
 # 检测文件路径是否有效，无效则跳过 
 if not os.path.isfile(filePath): 
 print('Invalid Path: ' + filePath) 
 continue 
 # 重置检测器 
 detector.reset() 
 # 以二进制模式读取文件 
 for each in open(filePath, 'rb'): 
 # 检测器读取数据 
 detector.feed(each) 
 # 若检测完成则跳出循环 
 if detector.done: 
 break 
 # 关闭检测器 
 detector.close() 
 # 读取结果 
 charEncoding = detector.result['encoding'] 
 confidence = detector.result['confidence'] 
 # 打印信息 
 if charEncoding is None: 
 charEncoding = 'Unknown' 
 confidence = 0.99 
 print('{} {:&gt;12} : {}'.format(charEncoding.rjust(8), 
 '('+str(confidence*100)+'%)', filePath)) 
 if args.encoding and charEncoding != 'Unknown' and confidence &gt; 0.6: 
 # 若未设置输出目录则覆盖源文件 
 outputPath = args.output + os.path.basename(filePath) if args.output else filePath 
 with open(filePath, 'r', encoding = charEncoding, errors = 'replace') as f: 
 temp = f.read() 
 with open(outputPath, 'w', encoding = args.encoding, errors = 'replace') as f: 
 f.write(temp) 
</code></pre>
<ul>
<li>最后两个脚本内容选至实验楼的课程《使用 Python3 编写系列实用脚本》</li>
</ul>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://yleexie.github.io/tag/mJkwovp4y">
            <span class="flex-auto">Python</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://yleexie.github.io/post/ckt4Y7_N1">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  整理经常在H5移动端开发遇到的知识
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://yleexie.github.io/post/qGUCTCcrs">
                <h3 class="post-title">
                  一张图理清 Vue 3.0 的响应式系统
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '26e86b8acd36313b1772',
    clientSecret: 'c7fd619e3cde059a1e0815d515d06c0af2f6a5ff',
    repo: 'YLeeXIE.github.io',
    owner: 'YLeeXIE',
    admin: ['YLeeXIE'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://yleexie.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
